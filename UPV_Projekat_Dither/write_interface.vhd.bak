library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity write_interface is

	port
	(
		din : in std_logic_vector(2 downto 0);
		adr : in std_logic_vector(18 downto 0); --307200 pix -> 19 bits needed
		w_e : in std_logic;
		vsync:in std_logic;
		clk : in std_logic;
		reset : in std_logic
 	);
end write_interface;

architecture write_interface_arch of write_interface is
	type state_type is ( WAIT_FRAME, IDLE, WRT, WRT_LATCH );
	signal current_state, next_state : state_type := WAIT_FRAME;
	signal data_buf, data_latch : std_logic_vector(15 downto 0);
	signal adress_buf, adress_latch : std_logic_vector(21 downto 0);
	signal current_frame : unsigned(1 downto 0);
begin
	
next_state_logic:
	process ( current_state, vsync, w_e, new_adress) is
	begin
		case (current_state) is
			when WAIT_FRAME =>
				if (vsync = '1') then
					next_state <= WAIT_FRAME;
				else
					next_state <= IDLE;
				end if;
			when IDLE =>
				if (w_e = '1') then
					if (new_adress = '1') then
						next_state <= WRT_LATCH;
					else
						next_state <= WRT;
					end;
				elsif (vsync = '1') then
					next_state <= WAIT_FRAME;
				else
					next_state <= IDLE;
				end if;
			when WRT | WRT_LATCH =>
				next_state <= IDLE:
		end case;
	end process;
	
state_transition:
	process (clk, reset) is
	begin
		if (reset = '1') then
			current_state <= WAIT_FRAME;
			current_frame <= "00";
			data_buf <= (others => '0');
			data_latch <= (others => '0');
			adr_buf <= (others => '0');
			adr_latch <= (others => '0');
		elsif (rising_edge(clk)) then
			current_state <= next_state;
			case (next_state) is
				when WAIT_FRAME =>
					if (current_state = IDLE) then
						current_frame <= current_frame + 1;
					end if;
				when WRT | WRT_LATCH =>
					case (adr(1 downto 0)) is
						when "00" =>
							data_buf(2 downto 0) <= din;
						when "01" =>
							data_buf(6 downto 4) <= din;
						when "10" =>
							data_buf(10 downto 8) <= din;
						when "11" =>
							data_buf(14 downto 12) <= din;
						when others =>
					end case;
					if (next_state = WRT_LATCH) then
						adr_buffer <= (21 downto 20 => current_frame, 16 downto 0 => adr(18 downto 2), others => '0');
						adr_latch <= adr_buf;
						data_latch <= data_buf;
					end if;
				others =>
			end case;
		end if;
	end;
	
	
end write_interface_arch;
