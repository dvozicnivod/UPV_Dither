library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

--When given a new address on read or write it will read/ write the date on the data line
--into memory and output a 1 on the complete line
--must give it at least 5% of unused time for refreshing, continuous use no more than 60ms
--read has priority over write
--after reset cannot read max address initially. lol, doesn't need to be perfect :)


entity SDRAM_control is
	port
	(
		reset : in	std_logic;
		clk	: in	std_logic;
		a_write, a_read : in std_logic_vector(21 downto 0); --nisam tacno siguran, 22 za 4M x 16 valjda :D
		d_write	:	in std_logic_vector(15 downto 0);
		d_read	:	out std_logic_vector(15 downto 0);
		w_complete	: out std_logic;
		r_complete	: out std_logic;
		--Interface with SDRAM
		a_sdram 	: out std_logic_vector(13 downto 0);	--gornja 2 bita bank select
		dq_sdram 	: inout std_logic_vector(15 downto 0);
		cs_n		:	out std_logic;
		ras_n		:	out std_logic;
		cas_n 	:	out std_logic;
		dqmh,dqml:	out std_logic;  --mozda potrebna 2
		we_n		:	out std_logic;
		clk_en	:	out std_logic;
	);
end SDRAM_control;


architecture SDRAM_control_arch of SDRAM_control is
	constant SETUP_CYCLES:integer := 32768;
	constant INIT_CYCLES :integer :=  SETUP_CYCLES + 2 + 8*8 + 2;
	type state_type is ( IDLE, INIT, READ_CYCLE, WRITE_CYCLE, REFRESH_CYCLE );
	
	signal state_cnt : integer range 0 to INIT_CYCLES := 0;
	signal current_state, next_state : state_type := INIT;
	signal p_a_read, p_a_write : std_logic_vector(21 downto 0);
	signal read_req, write_req : std_logic;
begin
	clk_en <= '1';
RW_request:
	process (a_write,a_read,p_a_write,p_a_read) is
	begin
		if NOT (a_read = a_p_read) then
			write_req <= '1';
		else 
			write_req <= '0';
		end if;
		if NOT(a_write = a_p_write) then
			write_req <= '1';
		else
			write_req <= '0';
		end if;
	end;

next_state_logic:
	process (current_state, write_req, read_req) is
	begin
		case (current_state) of
			when INIT =>
				if not(init_cnt = INIT_CYCLES)
					next_state <= INIT;
				else
					next_state <= IDLE;
				end if;
			when IDLE =>
				if (read_cycle = '1') then
					next_state <= READ_CYCLE;
				elsif (write_cycle = '1') then
					next_state <= WRITE_CYCLE;
				else
					next_state <= REFRESH_CYCLE;
				end if;
			when OTHERS =>
				if (state_cnt = 6) then
					next_state <= IDLE;
				else
					next_state <= current_state;
				end if;
		end case;
	end;
	
state_transition:			--BITNO, radi na falling edge da bi spremio signale za SDRAM na rising
	process (reset, clk) is
	begin
		if (reset = '1') then
			current_state <= INIT;
			p_a_read <= (others => '0');
			p_a_write <= (others => '1');
			state_cnt <= 0;
			init_cnt <= 0;
		elsif (falling_edge(clk)) then
			current_state <= next_state;
			if (next_state = INIT) then
				init_cnt <= init_cnt + 1;
			else
				init_cnt <= 0;
			end if;
			if (next_state = IDLE) then
				state_cnt <= 0;
			else 
				state_cnt <= state_cnt + 1;
			end if;
			--Lecovanje adresa, generisanje signala r,w complete
			case (current_state) is
				when READ_CYCLE =>
					if (state_cnt = 6) then
						p_a_read <= a_read;
					end if;
				when WRITE_CYCLE =>
					if (state_cnt = 6) then 
						p_a_write <= a_write;
					end if;
				when OTHERS =>
			end case;
		elsif (rising_edge(clk)) then
			if (current_state = READ_CYCLE AND state_cnt = 5) then
				d_read <= dq_sdram;	--zalecujemo podatak na izlaz u toku citanja rising
			end if;
		end if;
	end;
	
output_logic:
	process(current_state, state_cnt, init_cnt) is
	begin
		cs_n <= '1';
		ras_n <= '1'
		cas_n <= '1';
		dq_sdram <= (others => 'Z');
		dqmh <= '1';
		dqml <= '1';
		a_sdram <= (others => '1');
		we_n <= '1';
		case (current_state) is
			when INIT =>
				case (init_cnt) is
					when SETUP_CYCLES =>
						cs_n <= '0';
						ras <= '0';
						we_n <= '0';
						a10 <= '1'; --nepotrebno
					when SETUP_CYCLES+2 | SETUP_CYCLES+2+8 | SETUP_CYCLES+2+8*2 | SETUP_CYCLES+2+8*3 | SETUP_CYCLES+2+8*4 | SETUP_CYCLES+2+8*5 | SETUP_CYCLES+2+8*6 | SETUP_CYCLES+2+8*7 =>
						cs_n <= '0';
						cas_n <= '0';
						ras_n <= '0';
					when SETUP_CYCLES+2+8*8 => 
						cs_n <= '0';
						cas_n <= '0';
						ras_n <= '0';
						we_n <= '0';
						a_sdram(9 downto 0) <= "1000100000"; --burst 1, cas 2, serial read, burst 1
			when IDLE =>
			when READ_CYCLE =>
				case (state_cnt) is
					when 1 =>
						--activate row command
						cs_n <= '0';
						ras_n <= '0';
						a_sdram <= a_read(21 downto 8);
					when 3 =>
						--read collumn +PC command
						cs_n <= '0';
						cas_n <= '0';    
						a_sdram(7 downto 0) <= a_read(7 downto 0);
						a_sdram(13 downto 12) <= a_read(21 downto 20); --ovo je bank
						a_sdram(10) <= '1';	--znaci odradi PC
						dqmh <= '0';
						dqml <= '0';
				end case;
			when WRITE_CYCLE =>
				case (state_cnt) is
					when 1 =>
						--activate row command
						cs_n <= '0';
						ras_n <= '0';
						a_sdram <= a_write(21 downto 8);
						we_n <= '1';
					when 3 =>
						--read collumn +PC command
						cs_n <= '0';
						cas_n <= '0';    
						a_sdram(7 downto 0) <= a_write(7 downto 0);
						a_sdram(13 downto 12) <= a_write(21 downto 20); --ovo je bank
						a_sdram(10) <= '1';	--znaci odradi PC
						we_n <= '0';	--Radi se write
						dqmh <= '0';	--Mi postavljamo na DQ
						dqml <= '0';
						dq_sdram <= d_write;
					end case;
			when REFRESH_CYCLE =>
				if (state_cnt = 1) then
					cs_n <= '0';
					cas_n <= '0';
					ras_n <= '0';
				end if;
		end case;
	end;
			
	
	
	
	
	
	
			
		










end SDRAM_control_arch;
